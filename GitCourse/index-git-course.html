<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="git course">
    <meta name="author" content="hexlet.io">

    <title>Git course - hexlet.io</title>

  <!-- **************** Конспект курса по Git  **************** -->
  <!-- Lecture materials, saved for reference only. All rights to the materials belong to their owners. -->

  </head>

  
	<div id="wrapper">
	<hr>
		<h1>Introduction to Git </h1>
		<br>
		<h3>What you will learn?</h3>
		<br>
		<p>Course:<a href="https://ru.hexlet.io/courses/intro_to_git" target="_blank">Hexlet.io</a></p>
		<p>Копия этого конспекта:<a href="https://github.com/DerErde/listOfMyCourses/wiki/1_Git-course#integration-with-github" target="_blank">github</a></p>

		<ul>
		   <li>Lead development in accordance with current engineering practices</li>
		   <li>Effectively manage source code, add to the shared repository, analyze history, and modify it</li>
		   <li>Work with GitHub and contributing to open source projects</li>
  		</ul>

	<hr>

	<a href="#end">Вниз страницы</a>

	<hr>

	<h3>Course materials.</h3>
	<h4>Конспект по Git.</h4>

	<h4>Рабочий процесс — Введение в Git</h4>

	<p>Перед тем как погружаться в детали, пройдём поверхностно весь путь от создания проекта в git до начала
		отслеживания изменений. Затем, в следующих уроках поговорим подробнее про все этапы. В процессе изучим большое
		количество новых терминов и команд, которые нужны для понимания работы git.</p>

	<p>Git может отслеживать файлы проекта только в том случае, когда они помещены под контроль версий. Для этого нужно
		зайти в директорию проекта и выполнить команду инициализации <b>git init</b>. Проект может быть как новый, так и уже
		существующий. Процесс инициализации от этого не поменяется.</p>

	<code>	# Создаем новый проект
			<br>$ mkdir hexlet-git
			<br>$ cd hexlet-git
			<br>
			<br># Выполняем инициализацию
			<br>hexlet-git$ git init
			<br>Initialized empty Git repository in /private/tmp/hexlet-git/.git/
	</code>

	<p>Команда <b>git init</b> создает репозиторий — директорию .git, которая содержит все необходимые для работы git файлы.</p>

	<p>С помощью команды <b>git status</b> можно посмотреть статус репозитория:</p>

	<code>
		hexlet-git$ git status
		<br>On branch master
		<br>No commits yet
		<br>nothing to commit (create/copy files and use "git add" to track)
	</code>

		<p>В этом выводе указано, что репозиторий пустой (<i>No commits yet</i>) и в него нечего добавить,
			так как нет новых или изменённых файлов.
			<br>Давайте попробуем добавить несколько файлов:
		</p>

	<code>
		# Создаем файл README.md со строкой текста
		<br>hexlet-git$ echo 'Hello, Hexlet!' > README.md
		<br>hexlet-git$ echo 'Haskell Curry' > PEOPLE.md
	</code>

	<p>Теперь снова смотрим на статус:</p>

	<code>
		hexlet-git$ git status
		<br>
		<br># Часть вывода убрана
		<br>Untracked files:
		<br>(use "git add <file>..." to include in what will be committed)
		<br>PEOPLE.md
		<br>README.md
	</code>

	<p>Git увидел, что в проекте появились новые файлы, о которых ему ничего не известно.
		Они помечаются как <i>не отслеживаемые</i> (untracked files).
		<br>Git не следит за изменениями в таких файлах,
		так как они не добавлены в репозиторий. Добавление в репозиторий происходит в два шага.
		<br>Первым шагом выполняется команда подготовки файлов <b>git add путь-до-файла</b>:
	</p>

	<code>
		# Для каждого нового или измененного файла
		<br>hexlet-git$ git add README.md
	</code>

	<p>Смотрим что произошло:</p>

	<code>
		hexlet-git$ git status
		<br>Changes to be committed:
		<br>(use "git rm --cached <file>..." to unstage)
		<br>new file: README.md
		<br>Untracked files:
		<br>(use "git add <file>..." to include in what will be committed)
		<br>PEOPLE.md
	</code>

	<p>
		Файл README.md теперь находится в состоянии "готов к фиксации изменений" или, другими словами,
		файлы попадают в индекс. Под фиксацией понимается окончательное добавление в репозиторий,
		когда git запоминает файл навсегда и следит за всеми последующими изменениями.
	</p>

	<p>
		Все изменения, готовые к фиксации, попадают в репозиторий с помощью коммита.
		<br>Коммит — это операция, которая берёт все подготовленные изменения (они могут включать любое количество файлов)
		и отправляет их в репозиторий как единое целое.
		<br>Вот, как он выполняется:
	</p>

	<code>
		hexlet-git$ git commit -m 'add README.md'
		<br>[master (root-commit) 3c5d976] add README.md
		<br>1 file changed, 1 insertion(+)
		<br>create mode 100644 README.md
	</code>

	<p>
		Флаг <b>-m</b> означает message, то есть описание коммита. коммит можно выполнять и без него,
		но тогда откроется редактор, в котором нужно будет ввести описание коммита.
		<br>Мы рекомендуем делать осмысленные описания — это хороший тон.
		<br>Пример соглашения по именованию коммитов приведён в дополнительных материалов к уроку.
	</p>

	<p>
		Может возникнуть вопрос: зачем так сложно, зачем отдельно нужен индекс
		(куда попадают файлы после <b>git add</b>),
		и почему нельзя добавлять все изменённые файлы сразу в коммит?
		<br>Как ни странно, такой процесс создан как раз для удобства программистов.
		<br>Дело в том, что во время разработки может меняться и добавляться много файлов.
		<br>Но это не значит, что мы хотим добавить все эти изменения в один коммит.
	</p>

	<p>
		Со смысловой точки зрения, коммит — это какое-то логически завершённое изменение внутри проекта.
		<br>Его размер бывает очень маленьким, например, исправлением опечатки в одном файле, а иногда и большим,
		например, при внедрении новой функциональности.
		<br>Главное в коммите — его атомарность, то есть он должен выполнять ровно одну задачу.
	</p>

	<p>
		Теперь файл README.md находится внутри репозитория.
		<br>Убедиться в этом можно, запустив команду <b>git status</b>:
	</p>

	<code>
		hexlet-git$ git status
		<br>Untracked files:
		<br>(use "git add <file>..." to include in what will be committed)
		<br>PEOPLE.md
	</code>

	<p>
		<b>git status</b> не выводит файлы, которые добавлены в репозиторий и не содержат изменений.
		<br>При этом сам файл README.md находится внутри директории hexlet-git.
	</p>


	<hr> <!-- **************** Integration with Github  **************** -->

	<h4> Интеграция с Github </h4>

	<p>
		На текущий момент у нас есть репозиторий с двумя коммитами.
		<br>Содержимое директории hexlet-git выглядит так:
	</p>

	<code>
		hexlet-git$ ls -a
		<br>.git
		<br>PEOPLE.md
		<br>README.md
	</code>

	<p>
		Перед тем, как продолжить экспериментировать, добавим наш репозиторий на github.com.
		<br>Сохранённый репозиторий в любой момент можно извлечь и продолжить работу в нём с последнего
		добавленного туда коммита.
		<br>Это полезно на случай, если мы случайно удалим или изменим локальный репозиторий так,
		что с ним станет невозможно работать.
	</p>

    <ul>
		<li>Создайте репозиторий на Гитхабе. Назовите его hexlet-git.
			<br>Важно, чтобы репозиторий создавался пустым, поэтому не отмечайте галочки, добавляющие файлы.</li>

		<li>На странице репозитория вы увидите готовые команды для подключения созданного репозитория на Гитхабе
			к уже существующему репозиторию у вас на компьютере.</li>
	</ul>
		<p>Выполните эти шаги:</p>

	<code>
		# Подробнее эти команды мы разберём позже
		<br>hexlet-git$ git branch -M main
		<br>hexlet-git$ git remote add origin git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
		<br>hexlet-git$ git push -u origin main
	</code>

	<ul>
		<li>Обновите страницу с репозиторием на github.com. Изучите её интерфейс и содержимое репозитория.</li>
		<li>Обратите внимание на то, что директория .git отсутствует.
		Почему это так, мы узнаем в одном из следующих уроков.</li>
	</ul>




	<hr> <!-- **************** Git push  **************** -->




	<h4> Git push </h4>

	<p>
		После этой команды репозиторий, созданный на github.com, «соединяется» с локальным репозиторием <i>hexlet-git</i>.
		<br>В данном месте может возникнуть вопрос. Почему соединяется? Разве это не один и тот же репозиторий?
	</p>

	<p>
		В действительности это разные репозитории.
		<br>Git относится к так называемым распределённым системам контроля версий. У git нет какого-то центрального места,
		где бы лежал один главный репозиторий, а разработчики работали с ним со своих компьютеров.
		<br>В git у каждого разработчика и даже на Github находится свой собственный полноценный репозиторий.
		<br>Эти репозитории git связывает между собой общей историей и возможностью обмениваться изменениями.
		<br>В примере выше именно команда <b>git push</b> отправляет изменения во вновь созданный репозиторий.
	</p>

	<p>
		Прямо сейчас, после выполнения команд выше, локальный и удалённый репозиторий идентичны.
		<br>Но в процессе работы они всё время расходятся, и программисты должны не забывать синхронизировать изменения:
		<br>заливать в репозиторий новые коммиты и забирать оттуда коммиты, сделанные другими разработчиками.
	</p>

	<p>
		Теперь не важно, какие изменения делаются в локальном репозитории, на Github все коммиты попадут
		только после команды <b>git push</b>.
		<br>Не забывайте делать её, бывает такое,
		что разработчик случайно удаляет локальный репозиторий, забыв запушить (от слова push) изменения.
	</p>

	<p>
		Далее мы попробуем скачать репозиторий с Гитхаба так, как будто у нас нет локальной копии.
		<br>Для этого удалите директорию проекта hexlet-git с вашего компьютера.
	</p>

	<h4>Клонирование</h4>

	<p>
		Репозиторий, созданный на Github, — публичный. Любой человек может клонировать его к себе на компьютер и
		начать работать с ним так, как будто это его личный репозиторий.
		<br>Единственное ограничение — он не сможет запушить изменения,
		так как Github не даёт напрямую менять чужие репозитории.
	</p>

	<p>
		Клонирование — базовая операция при работе с удалёнными репозиториями.
		<br>Проекты, над которыми работают программисты, всегда находятся в системах, подобных Github.
		<br>Для работы с ними нужно клонировать репозиторий к себе на компьютер.
		<br>Делается это с помощью команды <b>git clone</b>.
		<br>Полную команду для клонирования можно получить на странице репозитория.
		<br>Для этого нажмите большую кнопку Code, перейдите на вкладку SSH и скопируйте содержимое.
	</p>

	<code>
		$ git clone git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git
		<br>$ cd hexlet-git
		<br>$ ls -la
		<br># Если эта операция проходит первый раз
		<br># То вероятно вы увидите такое подобное сообщение
		<br>The authenticity of host github.com cannot be established. RSA key fingerprint is SHA256: хххххххххх
		<br>Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning:
		<br>Permanently added github.com (RSA) to the list of known hosts.
		<br># Наберите yes и нажмите Enter
	</code>

	<p>Мы получили точную копию репозитория, который был у нас до удаления директории hexlet-git.</p>

	<h4>Getting changes from Github</h4>

	<p>Получение изменений с Github.</p>

	<p>
		Разработчики не только отправляют изменения на Гитхаб, но и забирают изменения оттуда.
		<br>Чаще всего это изменения, сделанные другими разработчиками проекта, но не обязательно.
		<br>Бывает такое, что один разработчик работает над одним проектом с разных компьютеров,
		<br>на каждом из которых своя собственная копия репозитория (git работает только так).
		<br>В таком случае, перед началом работы нужно всегда выполнять команду <b>git pull --rebase</b>,
		<br>которая скачивает из внешнего репозитория новые коммиты и добавляет их в локальный репозиторий.
	</p>

	<h4>Git pull --rebase</h4>

	<i>
		Обычно, в статьях пишут, что достаточно вызывать <b>git pull</b>, но это может приводить к созданию
		ненужных merge-коммитов, ухудшающих историю изменений.
		<br>Правильная работа с git pull требует знания таких вещей,
		как ветвление и <b>git rebase</b>. Они довольно сложны для новичков и рассматриваются позже,
		когда появится хоть какой-то опыт работы с git.
	</i>

	<p>Total</p>

	<p>
		Подведём некоторый итог. Мы создали репозиторий с несколькими коммитами. Этот репозиторий добавлен на Гитхаб и
		может быть склонирован для дальнейшей разработки. Какую пользу из git мы можем извлечь к текущему моменту?
		У нас есть запасная копия (бекап) кода на сайте Github. Как минимум, не страшно потерять код.
		Теперь его легко восстановить при случае и поделиться с другими.
	</p>

	<p>
		Отдельно стоит сказать, что Гитхаб это хоть и самая популярная, но не единственная площадка
		для хостинга репозиториев. Кроме него особенно известны Bitbucket и Gitlab.
		Последний можно даже поставить к себе на сервер и "хостить" репозитории внутри своей компании,
		что многие и делают по соображениям безопасности или экономии.
	</p>

	<p>Test task:</p>

	<code>
		git clone repos/git-user code-user
		<br>cd code-user/
		<br>echo 'I like to change files' >> hexlet.txt
		<br>echo 'С помощью гит можно писать книги' > index.html
		<br>git add .
		<br>git config --global user.email "you@example.com"
		<br>git config --global user.name "Your Name"
		<br>git commit -m 'fix hexlet.txt and index.html'
		<br>git push
	</code>


		

	<hr> <!-- **************** Working Directory  **************** -->




	<h4>Working Directory</h4>

	<p>
		После клонирования hexlet-git внутри мы можем увидеть директорию <b>.git</b> и добавленные нами файлы.
		Что произойдет если попробовать удалить один из файлов?
	</p>

	<p><b>git rm</b></p>

	<code>
		hexlet-git$ rm PEOPLE.md
		<br>
		<br>hexlet-git$ git status
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br>
		<br>Changes not staged for commit:
		<br>(use "git add/rm <file>..." to update what will be committed)
		<br>(use "git restore <file>..." to discard changes in working directory)
		<br>deleted: PEOPLE.md
		<br>no changes added to commit (use "git add" and/or "git commit -a")
	</code>

	<p>
		Git сообщает о том, что файл был удалён, и предлагает команды для восстановления или
		фиксации (коммита) изменений. Здесь стоит остановиться и немного погрузиться в то, как работает git.
		<br>Откуда он вообще знает, что файл был удалён?
	</p>

	<p>
		Внутри директории проекта мы видим файлы проекта с одной стороны и директорию .git с другой.
		<br>Репозиторием является именно директория .git. Она хранит всю информацию о том, какие были изменения,
		а также сами изменения. А вот всё, что находится снаружи,
		это так называемая рабочая директория (working directory).
		<br>Эти файлы (и директории, если они есть) извлекаются из .git в момент клонирования.
		<br>Каждый раз, когда мы производим изменения в рабочей директории, git сравнивает изменённые файлы с
		файлами внутри .git, то есть их состоянием на момент последнего коммита.
		<br>Если есть изменения относительно последней зафиксированной версии,
		то git сообщает нам об этом в выводе <b>git status</b>.
	</p>

	<p>В этом очень легко убедиться, если последовать совету git в выводе выше и восстановить удалённый файл:</p>

	<code>
		hexlet-git$ git restore PEOPLE.md
		<br>
		<br>hexlet-git$ git status
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br>nothing to commit, working tree clean
		<br># Сам файл вернулся на место таким, каким он был на момент последнего коммита
	</code>

	<p>
		Можно удалить всю рабочую директорию целиком и потом без проблем восстановить её.
		<br>Так мы достигаем важной цели — делаем возможным быстрое восстановление последней версии кода, если изменения,
		которые мы делали, нас больше не устраивают.
		<br>Или мы можем закоммитить их, если это нужно:
	</p>

	<code>
		hexlet-git$ rm PEOPLE.md
		<br>
		<br># Любое изменение обязательно добавлять в индекс
		<br>hexlet-git$ git add PEOPLE.md
		<br>
		<br>hexlet-git$ git commit -m 'remove PEOPLE.md'
		<br>[main e15afd2] remove PEOPLE.md
		<br>1 file changed, 1 deletion(-)
		<br>delete mode 100644 PEOPLE.md
		<br># Теперь этот файл пропал из рабочей директории
	</code>

	<p>
		Обратите внимание на важную деталь. Независимо от того, удаляем мы файл, добавляем или меняем,
		процедура выполнения коммита не меняется. После изменений всегда делается <b>git add</b>,
		который подготавливает изменение к коммиту (а не добавляет файл!), и после этого выполняется коммит.
	</p>

	<p>Кстати, у git есть команда <b>git rm</b>, которая объединяет в себе удаление и подготовку к коммиту:</p>

	<code>
		hexlet-git$ git rm PEOPLE.md
		<br># равносильно rm + git add
	</code>



	<hr> <!-- **************** Analysis of changes made  **************** -->


	<h4>Analysis of changes made</h4>

	<p>
		Во время разработки программистам часто приходится останавливаться и анализировать изменения,
		которые они сделали с последнего коммита. Потребность смотреть изменения становится очевидной,
		если представить себе, что такое работа над реальным проектом.
		<br>Как правило, это тысячи (десятки и сотни тысяч) строк кода, сотни и тысячи файлов и иногда
		несколько дней работы. Потратив даже несколько часов над работой в таком проекте,
		очень сложно вспомнить что и где менялось, а что ещё осталось поменять.
	</p>

	<p>
		Анализировать изменения важно даже в небольших проектах.
		<br>Прямо сейчас во время разработки этого курса изменилось несколько файлов и <b>git status</b> выглядит так:
	</p>

	<code>
		git_course$ git status
		<br>
		<br>Changes to be committed:
		<br>(use "git restore --staged <file>..." to unstage)
		<br>modified: 300-working-directory/README.md
		<br>
		<br>Changes not staged for commit:
		<br>(use "git add <file>..." to update what will be committed)
		<br>(use "git restore <file>..." to discard changes in working directory)
		<br>
		<br>modified: 100-intro/README.md
		<br>modified: 250-github/README.md
		<br>modified: 300-working-directory/README.md
		<br>modified: 300-working-directory/spec.yml
		<br>modified: 350-changes/README.md
	</code>

	<p>Попробуем воспроизвести подобную ситуацию в нашем проекте.
		<br>Выполним следующий код в репозитории <i>hexlet-git</i>:</p>

	<code>
		hexlet-git$ echo 'new line' >> INFO.md
		<br>hexlet-git$ echo 'Hello, Hexlet! How are you?' > README.md
		<br>hexlet-git$ git status
		<br>
		<br>Changes not staged for commit:
		<br>(use "git add <file>..." to update what will be committed)
		<br>(use "git restore <file>..." to discard changes in working directory)
		<br>modified: INFO.md
		<br>modified: README.md
		<br>no changes added to commit (use "git add" and/or "git commit -a")
	</code>

	<p><b>git diff</b></p>

	<p>
		Изменились оба файла. В один мы добавили строчку, в другом заменили.
		<br>Как теперь посмотреть эти изменения?
		<br>Для этого в git есть команда git diff, которая показывает разницу между тем, что было и что стало:
	</p>

	<code>
		hexlet-git$ git diff
		<br>
		<br>diff --git a/INFO.md b/INFO.md
		<br>index d5225f8..40f51f1 100644
		<br>
		<br>--- a/INFO.md
		<br>+++ b/INFO.md
		<br>@@ -1 +1,2 @@
		<br>git is awesome!
		<br>+new line
		<br>diff --git a/README.md b/README.md
		<br>index ffe7ece..00fd294 100644
		<br>
		<br>--- a/README.md
		<br>+++ b/README.md
		<br>@@ -1 +1 @@
		<br>-Hello, Hexlet!
		<br>+Hello, Hexlet! How are you?
	</code>

	<p>
		Вывод команды поначалу может смутить. Здесь довольно много служебных данных, за которыми уже идут изменения.
		<br><b>git diff</b> выводит именно те строки, которые изменились (и иногда строки вокруг измененных
		для удобства анализа),
		<br>а не файлы целиком. Слева от них ставится знак "-", если строка была удалена, и "+" для добавленных строк.
	</p>

	<p>
		Сама команда не просто выводит на экран разницу между файлами, но и запускает
		<a href="https://ru.hexlet.io/courses/cli-basics/lessons/read-files/theory_unit" target="_blank">пейджер</a>
		— специальную программу, которая позволяет перемещаться по выводу и искать внутри него нужные данные.
		<br>Для перемещения вниз по дифу нужно нажать <b>f</b>, для перемещения наверх — <b>u</b>
		<br>Для выхода из режима просмотра нажмите <b>q</b>.
	</p>

	<p>
		По умолчанию <b>git diff</b> показывает изменения только для тех модифицированных файлов,
		которые ещё не были добавлены в индекс. Подразумевается, что добавленные в индекс файлы смотреть не нужно,
		ведь мы их уже подготовили к коммиту. В реальности же часто хочется и, более того, нужно увидеть эти изменения.
		<br>Для этого нужно запустить команду вывода дифа с флагом <b>--staged</b>:
	</p>

	<code>
		# Выведет все изменения сделанные в рабочей директории
		<br># которые были добавлены в индекс
		<br>hexlet-git$ git diff --staged
	</code>

	<p>
		<b>git diff</b> — команда, которую нужно обязательно запускать перед каждым коммитом.
		<br>Она позволяет проанализировать добавляемые изменения и исправить возможные ошибки.
		<br>Иногда программисты по ошибке добавляют в коммит то, что туда не должно попасть.
	</p>




	<hr> <!-- **************** Change history analysis (commits)  **************** -->


	<h4>Change history analysis (commits)</h4>

	<p>
		Анализ истории изменений (коммитов). Программирование — это не только написание нового кода,
		но и постоянный анализ уже написанного кода. Иногда код понятен и без слов (это хороший код),
		но так происходит не всегда.
		<br>Код может вызывать вопросы. Почему он написан именно так, кто его написал и когда.
	</p>

	<p>
		Ответить на эти вопросы помогает история изменений. Если коммиты сделаны хорошо, то есть они имеют
		понятное описание, и каждый из них делает ровно одну законченную вещь, то история становится
		мощным инструментом для анализа кода. Именно поэтому так важно хорошо понимать философию Git и
		следовать лучшим практикам при работе с ним.
	</p>

	<p>
		Git предоставляет целую пачку команд со множеством опций,
		позволяющих вытащить невероятное количество информации и показать всё, что скрыто.
	</p>

	<h4>Git Log</h4>

	<p>
		Самая простая аналитика выполняется командой <b>git log</b>. Она показывает список всех выполненных коммитов,
		отсортированных по дате добавления (сверху самые последние):
	</p>

	<code>
		hexlet-git$ git log
		<br>
		<br># Ниже неполный вывод истории проекта
		<br>commit 5120bea3e5528c29f8d1da43731cbe895892eb6d
		<br>Author: tirion <tirion@got.com>
		<br>Date: Thu Sep 17 18:04:19 2020 -0400
		<br>add new content
		<br>
		<br>commit e6f625cf8433c8b1f1aaed58cd2b437ec8a60f27
		<br>Author: tirion <tirion@got.com>
		<br>Date: Thu Sep 17 16:14:09 2020 -0400
		<br>add INFO.md
		<br>
		<br>commit 273f81cf2117044f1973ea80ce1067a94bea3f80
		<br>Author: tirion <tirion@got.com>
		<br>Date: Thu Sep 17 16:08:39 2020 -0400
		<br>remove NEW.md
		<br># Этот вывод показывается через пейджер
	</code>

	<p>
		Из этого вывода мы можем узнать кто, когда и какие коммиты делал.
		Если коммиты оформлены хорошо, то по их описанию уже многое понятно.
		Оформление коммитов — отдельная тема, которую мы рассмотрим позже.
	</p>

	<p>
		У команды <b>git log</b> есть полезный флаг <b>-p</b>, который сразу выводит <b>диф</b> для каждого коммита:
	</p>

	<code>
		hexlet-git$ git log -p
		<br>
		<br># Тут все коммиты с полным дифом
		<br># Мотать вперед f, мотать назад b
		<br># Выйти из режима просмотра — q
	</code>
		
	<h4>Git Show</h4>

	<p>
		У каждого коммита есть идентификатор (говорят "<b>хеш</b>"), уникальный набор символов.
		<br>С помощью хеша можно посмотреть все изменения, сделанные в рамках одного коммита:
	</p>

	<code>
		hexlet-git$ git show 5120bea3e5528c29f8d1da43731cbe895892eb6d
		<br>
		<br># Тут выводится диф между этим коммитом и предыдущим
		<br>diff --git a/INFO.md b/INFO.md
		<br>index d5225f8..40f51f1 100644
		<br>
		<br>--- a/INFO.md
		<br>+++ b/INFO.md
		<br>@@ -1 +1,2 @@
		<br>git is awesome!
		<br>+new line
		<br>diff --git a/README.md b/README.md
		<br>index ffe7ece..00fd294 100644
		<br>
		<br>--- a/README.md
		<br>+++ b/README.md
		<br>@@ -1 +1 @@
		<br>-Hello, Hexlet!
		<br>+Hello, Hexlet! How are you?
		<br># То есть то, что было изменено этим коммитом
	</code>

	<p>
		Хеши коммитов в <b>git</b> очень длинные, и ими бывает неудобно пользоваться. Поэтому разработчики git добавили
		возможность указывать только часть хеша. Достаточно взять первые 8 символов и подставить их в ту команду,
		которая работает с коммитами:
	</p>

	<code>
		hexlet-git$ git show 5120bea3
	</code>

	<p>
		Чаще всего вам не придётся высчитывать их самим, большая часть команд git выводит хеш коммита в сокращенном
		варианте, облегчая его использование.
		Такое упрощение хорошо работает, потому что даже первые 8 символов будут всегда уникальными.
	</p>

	<h4>Git Blame</h4>

	<p>
		А что если мы не знаем коммита, но нам интересно, кто последним менял конкретную строку в файле?
		Для этого подойдет команда
		<code>git blame <путь до файла></code>.
		Эта команда выводит файл и рядом с каждой строкой показывает того, кто её менял и в каком коммите.
	</p>

	<code>
		hexlet-git$ git blame INFO.md
		<br>e6f625cf (tirion 2020-09-17 16:14:09 -0400 1) git is awesome!
		<br>5120bea3 (tirion 2020-09-17 18:04:19 -0400 2) new line
	</code>

	<p>
		Важно помнить, что изменение строчки — не то же самое, что её написание. Вполне возможно,
		что программист исправил небольшую опечатку, а саму строку написал кто-то до него.
		В любом случае, имея такой вывод, уже легко пойти дальше и изучить конкретный коммит.
	</p>

	<h4>Git Grep</h4>

	<p>
		Команда <b>git grep</b> ищет совпадение с указанной строкой во всех файлах проекта.
		Это очень удобная команда для быстрого анализа из терминала.
		Она удобнее обычного <b>grep</b>, так как знает про игнорирование и не смотрит в директорию <b>.git</b>,
		а ещё умеет искать по истории:
	</p>

	<code>
		hexlet-git$ git grep line
		<br>
		<br>INFO.md:new line
		<br># Флаг i позволяет искать без учета регистра
		<br>hexlet-git$ git grep -i hexlet
		<br>README.md:Hello, Hexlet! How are you?
		<br>
		<br># Поиск в конкретном коммите
		<br>hexlet-git$ git grep Hexlet 5120bea3
		<br>
		<br># Поиск по всей истории
		<br># rev-list возвращает список хешей коммитов
		<br>hexlet-git$ git grep hexlet $(git rev-list --all)
	</code>

	<p><b>Github</b></p>

	<p>
		В простых ситуациях анализировать проект можно прямо на Гитхабе.
		Он позволяет просматривать историю коммитов, изменения в конкретном коммите и многое другое.
	</p>

	<p>Самостоятельная работа</p>

	<p>
		Попробуйте изучить историю репозитория:
		<a href="https://github.com/Hexlet/ru-local-communities" target="_blank">ru-local-communities</a>
	</p>

	<p>Решение задачи на сайте:</p>

	<code>
		cd code-user/ # Переходим в директорию code-user
		<br>git log -p
		<br>echo 'Hello Hexlet!' > hexlet2.txt
		<br>git add hexlet2.txt
		<br>git commit -m 'fix hexlet2.txt'
	</code>




	<hr> <!-- **************** Undoing changes in the working directory  **************** -->


	<h4>Undoing changes in the working directory</h4>

	<p>Отмена изменений в рабочей директории</p>

	<p>
		Одна из
		<a href="https://ru.hexlet.io/courses/intro_to_git/lessons/changes-cancelation/theory_unit" target="_blank">ключевых возможностей</a>
		<b>git</b> — "откат" любых сделанных изменений буквально одной командой.
		Такое практически невозможно сделать без использования системы контроля версий.
		Только если помнить все изменения наизусть. В этом уроке мы поговорим про откат изменений,
		которые сделаны в рабочей директории, но ещё не попали в коммит.
	</p>

	<p>
		Важно! Откат незакоммиченных изменений безвозвратен.
		Не существует никакой физической возможности получить эти изменения обратно, поэтому будьте крайне осторожны.
	</p>

	<p><b>Untraceable files</b></p>

	<p>
		Самая простая ситуация. Вы добавили новые файлы в репозиторий (или сгенерировали их как-то) и поняли,
		что они вам не нужны. В этом случае можно выполнить очистку:
	</p>

	<code>
		hexlet-git$ mkdir one
		<br>hexlet-git$ touch two
		<br>hexlet-git$ git status
		<br>
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br># Пустые директории в git не добавляются в принципе.
		<br># Физически директория one находится в рабочей директории,
		<br># но её нет в git, и он её игнорирует
		<br>
		<br>Untracked files:
		<br>(use "git add <file>..." to include in what will be committed)
		<br>two
		<br># Выполняем очистку
		<br># -f – force, -d – directory
	</code>

	<h4>git clean -fd</h4>

	<p>(удаляет файлы и директории, не добавленные в отслеживание)</p>

	<code>
		hexlet-git$ git clean -fd
		<br>Removing one/
		<br>Removing two
	</code>

	<p>Забавный факт: про эту команду знает не так много программистов. Вы можете удивить даже опытных ребят.</p>

	<h4>Changed files in the working directory</h4>

	<h4>git restore</h4>

	<p>
		(Команда не сработает, если файл не закомитчен)
		<br>Для отмены изменений в таких файлах используется команда <b>git restore</b>.
		<br>Причём <b>git</b> сам напоминает об этом при проверке статуса:
	</p>

	<code>
		hexlet-git$ echo 'new text' > INFO.md
		<br>
		<br>hexlet-git$ git status
		<br>
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br>Changes not staged for commit:
		<br>(use "git add <file>..." to update what will be committed)
		<br>
		<br># Ниже написано, как отменить изменение
		<br>(use "git restore <file>..." to discard changes in working directory)
		<br>modified: INFO.md
		<br>
		<br># Отменяем
		<br>hexlet-git$ git restore INFO.md
	</code>

	<h4>Files added for committal</h4>

	<p>
		Файлы, добавленные для фиксации. С файлами, подготовленными к коммиту, можно поступить по-разному.
		<br>Первый вариант — отменить изменения совсем, второй — переместить изменения из индекса в рабочую директорию.
		<br>Второе полезно в том случае, если изменения нам нужны, но мы не хотим их коммитить сейчас.
	</p>

	<code>
		hexlet-git$ echo 'new text' > INFO.md
		<br>hexlet-git$ git add INFO.md
		<br>hexlet-git$ git status
		<br>
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br>Changes to be committed:****
		<br>(use "git restore --staged <file>..." to unstage)
		<br>modified: INFO.md
	</code>

	<p>
		И здесь снова помогает git.
		При выводе статуса он показывает нужную нам команду для перевода изменений в рабочую директорию:
	</p>

	<code>
		hexlet-git$ git restore --staged INFO.md
		<br>hexlet-git$ git status
		<br>
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br>Changes not staged for commit:
		<br>(use "git add <file>..." to update what will be committed)
		<br>(use "git restore <file>..." to discard changes in working directory)
		<br>modified: INFO.md
	</code>

	<p>Теперь, если нужно, можно выполнить <b>git restore</b> и окончательно отменить изменения в выбранных файлах.</p>

	<p>Test</p>

	<code>
		git restore info.txt
		<br>git restore --staged index.md index.html
		<br>git restore index.html
		<br>git clean -fd
	</code>




	<hr> <!-- **************** Cancel commits  **************** -->



	<h4>Cancel commits</h4>

	<p>Отмена коммитов.</p>

	<p>
		Гит — система, в которой не нужно бояться совершать ошибки.
		<br>Можно сказать, что это единственный способ научиться им пользоваться. В git практически всегда есть способ
		восстановить или изменить любые коммиты.
		<br>На крайний случай спасет повторный <b>git clone</b>.
	</p>

	<p>
		Что делать, если коммит уже сделан, но он нас по каким-то причинам не устраивает?
		Ситуаций может быть много, и все они возникают регулярно даже у профессиональных разработчиков:
	</p>

	<ul>
		<li>Забыли добавить в коммит нужные файлы</li>
		<li>Изменения нужно «откатить», чтобы доработать</li>
		<li>Изменения больше не актуальны, и их нужно удалить</li>
		<li>Изменения были сделаны по ошибке, и их нужно отменить</li>
	</ul>

	<p>
		Git по большей части система «только вперёд». Правильный подход при работе с гитом — создание нового,
		а не изменение старого. Все ситуации, описанные выше, можно решить новым коммитом,
		изменяющим код в нужном направлении. Это не только удобно, но и безопасно.
		<br>Изменение истории коммитов — операция опасная и чревата проблемами
		при синхронизации с удалёнными репозиториями. Об этом мы поговорим позже.
	</p>

	<p>
		Несмотря на сказанное выше, внутри git существуют специальные команды, позволяющие упростить отмену,
		либо изменение коммита.
		С их помощью можно сделать историю коммитов понятной, а сам процесс <i>отката</i> быстрым.
	</p>

	<h4>Git revert</h4>

	<p>
		Самая простая ситуация — отмена изменений. Фактически она сводится к созданию ещё одного коммита,
		который выполняет изменения противоположные тому коммиту, который отменяется.
		Руками создавать подобный коммит довольно сложно, поэтому в git добавили команду, автоматизирующую откат.
		<br>Эта команда называется git revert:
	</p>

	<p><a href="https://cdn2.hexlet.io/store/derivatives/original/510fab63e8d6f3f4992f7e4cfb88e77b.jpg" target="_blank">img</a></p>

	<code>
		# Этой команде нужен идентификатор коммита
		<br># Это коммит, которым мы удалили файл PEOPLE.md
		<br>
		<br>hexlet-git$: git revert aa600a43cb164408e4ad87d216bc679d097f1a6c
		<br>
		<br># После этой команды откроется редактор, ожидающий ввода описания коммита
		<br># Обычно сообщение revert не меняют, поэтому достаточно просто закрыть редактор
		<br>
		<br>[main 65a8ef7] Revert "remove PEOPLE.md"
		<br>1 file changed, 1 insertion(+)
		<br>create mode 100644 PEOPLE.md
		<br># В проект вернулся файл PEOPLE.md
		<br>
		<br>hexlet-git$ git log -p
		<br>commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
		<br>Author: tirion <tirion@got.com>
		<br>Date: Sat Sep 26 15:32:46 2020 -0400
		<br>Revert "remove PEOPLE.md"
		<br>
		<br>This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.
		<br>diff --git a/PEOPLE.md b/PEOPLE.md
		<br>new file mode 100644
		<br>index 0000000..4b34ba8
		<br>--- /dev/null
		<br>+++ b/PEOPLE.md
		<br>@@ -0,0 +1 @@
		<br>+Haskell Curry
	</code>

	<p>
		Команда <b>revert</b> может <i>отменять</i> не только последний коммит,
		но и любой другой коммит из истории проекта.
		Согласитесь, это очень круто. Без системы контроля версий о таком нельзя было и мечтать.
	</p>

	<h4>Git reset</h4>

	<p>
		Иногда удалить нужно только что сделанный по ошибке коммит.
		Конечно, и в этом случае подходит <b>git revert</b>, но так загрязняется история.
		<br>Если этот коммит сделан был только сейчас и ещё не отправлялся на Github,
		то лучше сделать так, как будто бы этого коммита не существовало в принципе.
	</p>

	<p>
		Git позволяет удалять коммиты. Это опасная операция, которую нужно делать только в том случае,
		если речь идет про новые коммиты, которых нет ни у кого, кроме вас.
	</p>

	<p>
		<i>
		 Если коммит был отправлен во внешний репозиторий, например, на Github,
		 то менять историю ни в коем случае нельзя, это сломает работу у тех, кто работает с вами над проектом.
		</i>
	</p>

	<p>Для удаления коммита используется команда git reset. Делается это так:</p>

	<code>
		# добавляем новый коммит, который мы сразу же удалим
		<br>
		<br>hexlet-git$ echo 'test' >> INFO.md
		<br>hexlet-git$ git add INFO.md
		<br>hexlet-git$ git commit -m 'update INFO.md'
		<br>
		<br>[main 17a77cb] update INFO.md
		<br>1 file changed, 1 insertion(+)
		<br>
		<br># Важно, что мы не делаем git push
		<br>hexlet-git$ git reset --hard HEAD~
		<br>HEAD is now at 65a8ef7 Revert "remove PEOPLE.md"
		<br>
		<br># Если посмотреть git log, то последнего коммита там больше нет
	</code>

	<p>
		<b>git reset</b> — мощная команда, имеющая множество различных флагов и способов работы.
		С её помощью удаляются или отменяются (без удаления) коммиты, восстанавливаются файлы из истории и так далее.
		Работа с ней относится к продвинутому использованию git, здесь же мы затрагиваем только самую базу.
	</p>

	<p>
		Флаг <b>--hard</b> означает полное удаление. Без него <b>git reset</b> отменит коммит, но не удалит его,
		а поместит все изменения этого коммита в рабочую директорию, так что с ними можно будет продолжить работать.
		<br><b>HEAD~</b> означает "один коммит от последнего коммита".
		<br>Если бы мы хотели удалить два последних коммита, то могли бы написать <b>HEAD~2</b>.
	</p>

	<p><a href="https://cdn2.hexlet.io/store/derivatives/original/27959c1cb7f5d9ee47bcd5e46b79bf14.jpg" target="_blank">img</a></p>

	<p>
		<i>
			HEAD (голова) — так обозначается последний сделанный коммит.
			<br>Подробнее эту терминологию мы разберем в уроке, посвященном внутреннему устройству git.
		</i>
	</p>

	<p>
		Если не указывать флаг <b>--hard</b>, то по умолчанию подразумевается флаг <b>--mixed</b>.
		В таком варианте reset отправляет изменения последнего коммита в рабочую директорию.
		Затем их можно исправить или отменить и выполнить новый коммит.
	</p>

	<code>
		hexlet-git$ echo 'no code no pain' > README.md
		<br>hexlet-git$ git add README.md
		<br>hexlet-git$ git commit -m 'update README.md'
		<br>
		<br>[main f85e3a6] update README.md
		<br>1 file changed, 1 insertion(+)
		<br>
		<br># Теперь откатываем последний коммит
		<br>hexlet-git$ git reset HEAD~
		<br>
		<br>Unstaged changes after reset:
		<br>M README.md
		<br>
		<br>hexlet-git$ git status
		<br>
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br>
		<br>Changes not staged for commit:
		<br>(use "git add <file>..." to update what will be committed)
		<br>(use "git restore <file>..." to discard changes in working directory)
		<br>modified: README.md
	</code>

	<p>
		Последнего коммита больше не существует, но изменения, сделанные в нём, не пропали.
		Они находятся в рабочей директории для дальнейшей доработки.
	</p>




	<hr> <!-- **************** Changing the last commit  **************** -->



	<h4>Changing the last commit</h4>

	<p><a href="https://ru.hexlet.io/courses/intro_to_git/lessons/git-commit-amend/theory_unit" target="_blank">Изменение последнего коммита.</a></p>

	<p>
		Крайне часто разработчики делают коммит и сразу же понимают,
		что забыли добавить часть файлов через <b>git add</b>.
		Оставшуюся часть изменений можно дослать следующим коммитом либо, если изменения ещё не были отправлены
		во внешнюю систему, можно добавить изменения в текущий коммит.
		<br>Для этого во время коммита добавляется флаг <b>--amend</b>:
	</p>

	<h4>git commit --amend</h4>

	<code>
		hexlet-git$ echo 'experiment with amend' >> INFO.md
		<br>hexlet-git$ echo 'experiment with amend' >> README.md
		<br>hexlet-git$ git add INFO.md
		<br>
		<br># Забыли сделать подготовку README.md к коммиту.
		<br>
		<br>hexlet-git$ git commit -m 'add content to INFO.md and README.md'
		<br>[main 256de25] add content to INFO.md and README.md
		<br>1 file changed, 1 insertion(+)
		<br>
		<br>hexlet-git$ git status
		<br>On branch main
		<br>Your branch is ahead of 'origin/main' by 1 commit.
		<br>(use "git push" to publish your local commits)
		<br>
		<br>Changes not staged for commit:
		<br>(use "git add <file>..." to update what will be committed)
		<br>(use "git restore <file>..." to discard changes in working directory)
		<br>modified: README.md
		<br>
		<br># Увидели, что забыли добавить файл. Добавляем.
		<br>
		<br>hexlet-git$ git add README.md
		<br>hexlet-git$ git commit --amend
		<br>
		<br>#После этой команды откроется редактор, ожидающий ввода описания коммита
		<br>#Здесь можно поменять сообщение или выйти из редактора, оставив старое
		<br>
		<br>[main d96151a] add content to INFO.md and README.md
		<br>Date: Sat Sep 26 16:02:07 2020 -0400
		<br>2 files changed, 2 insertions(+)
		<br>
		<br>hexlet-git$ git status
		<br>On branch main
		<br>Your branch is ahead of 'origin/main' by 1 commit.
		<br>(use "git push" to publish your local commits)
		<br>nothing to commit, working tree clean
	</code>

	<p>
		В реальности <b>--amend</b> не добавляет изменения в существующий коммит, этот флаг приводит к
		откату коммита (через reset) и выполнению нового коммита с новыми данными.
		<br>Поэтому мы и видим ровно один коммит, хотя команда <b>git commit</b> выполнялась два раза
		(первый раз — когда сделали ошибочный коммит).
	</p>

	<h4>git commit --amend --no-edit</h4>

	<p>
		Для того, чтобы не открывался редактор для ввода описания коммита
		к команде <b>git commit --amend</b> можно добавить опцию <b>--no-edit</b>.
		В этом случае описание коммита не изменится.
	</p>



	<hr> <!-- **************** index  **************** -->



	<h4>index</h4>

	<p>
		Индекс в Git — это специальная промежуточная область, в которой хранятся изменения файлов на пути
		от рабочей директории до репозитория.
		<br>При выполнении коммита в него попадают только те изменения, которые были добавлены в индекс.
	</p>

	<p>
		Понятие индекса в Git появилось не случайно. Даже когда разработчик работает над одной задачей,
		по пути он натыкается на разные места в коде, которые либо плохо оформлены, либо содержат ошибки,
		либо должны быть исправлены в соответствии с какими-то новыми требованиями.
		<br>И в большинстве ситуаций совершенно нормально исправлять эти недочеты, что все и делают.
		<br>В итоге в рабочей директории появляется множество разных исправлений, которые частично относятся
		к выполняемой задаче, а частично содержат множественные исправления,
		напрямую не связанные с основными изменениями.
		<br>В чём здесь проблема?
	</p>

	<p>
		Если делать ровно один коммит, включающий в себя и основную задачу, и дополнительные исправления,
		то появляется несколько неприятных побочных эффектов. Во-первых, сложнее смотреть историю.
		Коммит начинает содержать совершенно несвязанные изменения,
		которые отвлекают во время ревью (проверки чужого кода).
	</p>

	<code>
		# Обычно в таких коммитах встречается условие И в описании
		<br># Показатель того, что в рамках одного коммита сделано несколько изменений
		<br>$ git commit -m 'add new feature and fix something'
	</code>

	<p>
		Во-вторых, что вероятно даже важнее, откат коммита по любым причинам приведет к тому,
		что откатятся правки, которые всё равно нужно будет делать.
	</p>

	<p>
		Именно здесь помогает индекс. Его наличие позволяет меньше переживать на тему того, как сформируется коммит.
	</p>

	<p>
		Стандартный способ работы с индексом — это добавление или изменение файлов и последующий коммит:
	</p>

	<code>
		$ git add somefile
		<br>$ git commit -m 'add somefile'
	</code>

	<p>
		Если речь идет про один-два файла, которые нужно закоммитить прямо сейчас, то можно сделать проще.
		Команда <b>git commit</b> принимает на вход аргументы — пути до файлов. Она автоматически добавляет эти файлы
		в индекс и затем в коммит. Данный подход работает только с уже отслеживаемыми файлами.
	</p>

	<code>
		hexlet-git$ echo 'new data' >> INFO.md
		<br>
		<br># Не нужно явно вызывать git add
		<br>hexlet-git$ git commit INFO.md -m 'update INFO.md'
	</code>

	<p>
		Иногда бывает наоборот — мы исправили много файлов и хотим добавить их в коммит сразу все.
		<br>Тогда поможет точка:
	</p>

	<h4>git commit -am</h4>

	<code>
		# Добавляет абсолютно все изменения рабочей директории в индекс
		<br>$ git add .
	</code>

	<p>
		Команда выше очень опасна. С ее помощью крайне легко закоммитить много лишнего,
		особенно если не помнить про необходимость перед коммитом смотреть <b>git diff --staged</b>.
	</p>

	<p>Ну и совсем страшная, но полезная команда — это коммит с одновременным добавлением всего в индекс:</p>

	<code>
		# Флаг -a автоматически добавляет все изменения рабочей директории в индекс
		<br>$ git commit -am 'do something'
	</code>

	<h4>git add -i</h4>

	<p>
		С другой стороны, нередко разные изменения делаются в одних и тех же файлах.
		<br>То есть изменения в этих файлах по-хорошему должны находиться в разных коммитах.
		И даже такое можно сделать с помощью Git. Для этого подходит команда <b>git add -i</b>,
		которая показывает измененные куски файлов и спрашивает, что с ними сделать.
		<br>С помощью этой команды можно очень точно выбрать то, что должно попасть в коммит,
		а что нет. Ее использование обычно показывает хороший уровень владения Git.
	</p>

	<p><b>test</b></p>

	<p>
		Подробный разбор. Разделяем файл(файлы) на части для создания нескольких коммитов.
		<br>
		<br>(но это не всегда возможно.
		<br>Иногда, если коммиты в файле идут подряд, он не может разделить их)
	</p>

	<code>
		git diff -смотрим содержимое коммитов.
		<br>
		<br># Разобьём и добавим часть изменений в файл в индекс.
		<br>git add -i
		<br>
		<br>patch
		<br># Выбираем файл(номер строки) который будем разделять.
		<br># Нажимаем Enter - 2 раза! (только на сайте)
		<br>
		<br>s
		<br>y
		<br>n
		<br>status
		<br>quit
		<br>git status
		<br>git commit -m с коммитом для первой части нашего файла.
		<br>git diff смотрим оставшиеся не закоммитченные измениня в нашем файле.
		<br>git commit -am добавляет оставшиеся измениния в коммит.
	</code>
	<br>



	<hr> <!-- **************** Moving through history  **************** -->



	<h4>Moving through history</h4>

	<p>
		Git позволяет не только просматривать историю, но и перемещаться по ней,
		загружая в рабочую директорию состояние кода на момент выполнения любого коммита.
		<br>Посмотрим:
	</p>

	<h4>git log --oneline</h4>

	<p>Показывает сокращенный вывод</p>

	<code>
		git log --oneline
		<br>
		<br>fc74e2d update README.md
		<br>65a8ef7 Revert "remove PEOPLE.md"
		<br>5120bea add new content
		<br>e6f625c add INFO.md
		<br>273f81c remove NEW.md
		<br>aa600a4 remove PEOPLE.md
		<br>fe9893b add NEW.md
		<br>3ce3c02 add PEOPLE.md
		<br>3c5d976 add README.md
	</code>

	<h4>git checkout</h4>

	<p>
		Переключимся на момент, когда был выполнен коммит с сообщением <i>add INFO.md</i>.
		<br>Для этого используется команда <b>git checkout <хеш коммита>:</b>
	</p>

	<code>
		git checkout e6f625c
		<br>
		<br>Note: switching to 'e6f625c'.
		<br>You are in 'detached HEAD' state. You can look around, make experimental changes and commit them,
		<br>and you can discard any commits you make in this state without impacting any
		<br>branches by switching back to a branch.
		<br>
		<br>Or undo this operation with:
		<br>git switch -
	</code>

	<p>
		Выполните команду выше (хеш вашего коммита может отличаться) и изучите рабочую директорию.
		<br>Вы увидите, что пропала часть изменений из-за возврата в прошлое. Сами изменения никуда не делись,
		и мы снова можем вернуться на последний коммит следующей командой:
	</p>

	<code>
		# Что такое main, мы поговорим позже
		<br>git checkout main
	</code>

	<p>
		Переключившись в нужный коммит, можно не только изучить содержимое репозитория,
		но и забрать какие-то изменения, которые были удалены, но снова понадобились для работы.
		Для этого достаточно их скопировать, переключиться на последний коммит и вставить в нужный файл.
	</p>

    <h4>Где я.</h4>

	<p>
		Переключение по коммитам отражается только на содержимом рабочей директории.
		Больше нигде не видно, где мы находимся. Из-за этого немало программистов, забыв где они находятся,
		начинают работать и очень удивляются, когда не получается выполнить коммит.
	</p>

	<h4>git branch</h4>

	<p>
		Самый простой способ узнать место нахождения — вызвать команду git branch.
		В обычной ситуации, когда мы находимся на последнем коммите, git покажет такой вывод:
	</p>

	<code>
		git branch
		<br>
		<br># О том, что такое main, мы поговорим позже
		<br>* main
		<br>
		<br># Но если прямо сейчас загружен коммит из прошлого, то вывод станет таким:
		<br>* (HEAD detached at e6f625c)
		<br>main
	</code>

	<p>
		Такой способ проверки текущего местоположения требует постоянного внимания.
		<br>Нужно не забывать его использовать и, конечно же, все забывают это делать.
		Гораздо надежнее и удобнее вывести текущее местоположение прямо в командной строке.
		<br>Например, так:
	</p>

	<code>
		# Если на последнем коммите
		<br>hexlet-git git:(main)
		<br>
		<br># Если на коммите из прошлого
		<br>hexlet-git git:(e6f625c)
	</code>

	<p>
		Именно так делают большинство профессиональных разработчиков. Как добиться такого вывода?
		<br>Ответ на этот вопрос зависит от используемого командного интерпретатора.
		<br>В Bash вывод местоположения происходит благодаря редактированию переменной окружения <b>$PS1</b>,
		подробнее об этом вы можете почитать по ссылке в дополнительных материалах.
	</p>

	<p>test</p>

	<p>
		Чтобы найти в истории, незакомитченный файл например todo.md,
		<br>нужно добавить в <b>git log -p --oneline</b> через два тире и <b>пробел</b>, название файла -- todo.md
	</p>
		
	<code>
		git log -p --oneline -- todo.md
		<br>
		<br># Затем, перейти к нужной ветке.
		<br>git checkout 7c2fcf8
	</code>



	<hr> <!-- **************** Understanding Git  **************** -->



	<h4>Understanding Git</h4>

	<p><a href="https://ru.hexlet.io/courses/intro_to_git/lessons/thinking/theory_unit" target="_blank">Понимание GiT</a></p>

	<p>
		Обилие команд и возможностей могут повергнуть в ужас любого, кто только начинает изучать Git.
		<br>Git — это комбайн с невероятным количеством «фич». Но надо ли знать их все? И как их запомнить?
		<br>Как вообще научиться эффективно его использовать?
	</p>

	<p>
		Правда состоит в том, что почти никто не знает Git до конца, и разработчики регулярно открывают внутри него
		что-то новое, а еще постоянно гуглят его команды или смотрят man. Единственный способ изучить
		Git — постоянно использовать его. Причем наибольший эффект достигается при работе с Git в команде.
		Одиночная разработка в этом смысле сильно уступает, так как не затрагивает многих сложных ситуаций,
		возникающих только при совместной работе над одним и тем же кодом.
	</p>

	<p>
		С другой стороны, чтобы понять Git, нужно понять, как он устроен, на каких идеях базируется.
		И дальше всё станет проще, так как окажется, что подавляющее большинство команд — это всего лишь
		обертки над очень простой концепцией. В этом уроке мы попробуем немного разобраться с тем, что такое Git.
	</p>

	<p>
		Давайте выведем коммиты нашего проекта <i>hexlet-git</i> в специальном виде,
		<br>который активируется опцией <b>--graph</b>:
	</p>

	<h4>git log --graph</h4>

	<code>
		# Неполный вывод, чтобы не отвлекаться от сути
		<br>
		<br>* commit e7bb5e51f96e572084f6c04ba3312e32ce6b8c0f (HEAD -> main, origin/main, origin/HEAD)
		<br>| update README.md
		<br>|
		<br>* commit 65a8ef7fd56c7356dcee35c2d05b4400f4467ca8
		<br>|
		<br>| Revert "remove PEOPLE.md"
		<br>|
		<br>| This reverts commit aa600a43cb164408e4ad87d216bc679d097f1a6c.
		<br>|
		<br>* commit 5120bea3e5528c29f8d1da43731cbe895892eb6d
		<br>|
		<br>| add new content
		<br>|
		<br>* commit e6f625cf8433c8b1f1aaed58cd2b437ec8a60f27
		<br>|
		<br>| add INFO.md
		<br>|
		<br>* commit 273f81cf2117044f1973ea80ce1067a94bea3f80
		<br>|
		<br>| remove NEW.md
	</code>

	<p>
		Обратите внимание на полоску слева. Она отражает связи между коммитами.
		<br>Каждый новый коммит базируется на коде предыдущего коммита.
		С точки зрения информатики коммиты выстраиваются в так называемый односвязный список.
		В таком списке каждый элемент ссылается на предыдущий.
		<br>Последний элемент при этом называется головой списка (head по-английски).
	</p>

	<p>
		В Git элементы списка — это сами коммиты. И так же, как в односвязном списке, новый коммит (как элемент)
		имеет ссылку на старый (предыдущий), а предыдущий — на свой предыдущий, и так далее до первого коммита,
		который никуда не ссылается, так как он первый.
		<br>Понятие «голова списка» (HEAD) в git присутствует явно и активно используется для разных операций.
		<br>Например, удаление последнего коммита выглядит так:
	</p>

	<p>
		<b>HEAD~1</b> означает: взять голову и удалить, начиная от нее, один коммит
		<br>То есть только последний коммит
	</p>

	<h4>git reset --hard HEAD~1</h4>

	<p>
		Сам список коммитов тоже имеет название, вы его уже видели: это — <i>main</i>. В терминологии Git такой список
		называется веткой (<i>branch</i>).
		<br>Именно поэтому команда для показа текущего местоположения в истории называется <b>git branch</b>:
	</p>

	<code>
		git branch
		<br>* main
	</code>

	<p>
		Основная «работа» Git — формирование односвязного списка, состоящего из коммитов.
		Это — ключевое знание для понимания того, что такое Git.
		<br>Подавляющее большинство команд Git — это всего лишь небольшие программы, которые умеют ходить по этому списку
		и извлекать нужную информацию. Фактически всё сводится к блужданию по этому списку вперед назад и
		его изменению, включая добавление новых коммитов.
	</p>

	<p>
		Ветки.
		<br>
		<br>Если смотреть дальше, то мы увидим, что Git это не просто односвязный список —
		это множество односвязных списков, переплетенных вместе.
		<br>
		Представьте себе, что в один момент времени два разных человека должны делать какие-то длинные задачи,
		требующие нескольких дней разработки или даже больше. Main-ветка в таком случае должна оставаться рабочей,
		то есть коммитить промежуточные изменения в нее нельзя, так как они могут сломать её.
		<br>Но коммитить всё равно надо, так как просто небезопасно копить изменения в рабочей директории,
		не отправляя их в Git. Что делать в такой ситуации?
		<br>
		<br>Гит позволяет отпочковываться от основного списка, формируя «ветки».
		<br>То есть создается отдельный список коммитов, который идет мимо main.
		<br>В конце разработки все коммиты из такой ветки вливаются обратно в main.
	</p>

	<p><a href="https://cdn2.hexlet.io/store/derivatives/original/42e47c4dc0fd9eccb5e53670e503df38.jpg" target="_blank">img</a></p>

	<p>
		Ветки в Git — большая история, которая достойна отдельного курса.
		<br>Здесь мы про них рассказываем только потому, что невозможно работать с Git и не слышать про них.
	</p>

	<p>Дополнительные материалы</p>

	<p><a href="https://learngitbranching.js.org/?locale=ru_RU" target="_blank">Ветки в GIT</a></p>
	<p><a href="https://trunkbaseddevelopment.com/" target="_blank">Trunk Based Development</a></p>

	<p>test</p>

	<code>
		# переходим в ветку refactoring
		<br>git switch refactoring
		<br>git reset --hard HEAD~2
		<br>git switch working-on-html переходим в ветку working-on-html
		<br>
		<br># Редактируем и сохраняем файл или echo
		<br>vim index.html
		<br>git add index.html
		<br>git commit -m 'fix index.html'
	</code>




	<hr> <!-- **************** Ignoring files (Gitignore)  **************** -->



	<h4>Ignoring files (Gitignore)</h4>

	<p>
		В процессе работы над любым проектом в директории с кодом создаются файлы,
		которые не являются частью исходного кода.
		<br>Все эти файлы можно условно разделить на несколько групп:
	</p>

	<p>
		<b>Инструментарий</b>
		<ul>
			<li>Служебные файлы, добавляемые операционной системой (.DS_Store в Mac)</li>
			<li>Конфигурационные и временные файлы редакторов (например, .idea, .vscode)</li>
		</ul>
	</p>

	<p>
		<b>Временные файлы</b>
		<ul>
			<li>Логи. В них содержится полезная информация для отладки,
				которая собирается во время запуска и работы приложения</li>
			<li>Кеши. Файлы, которые нужны для ускорения разных процессов</li>
		</ul>
	</p>

	<p>
		<b>Артефакты</b>
		<ul>
			<li>Результаты сборки проекта. Например, после компиляции или сборки фронтенда</li>
			<li>Устанавливаемые во время разработки зависимости (например, node_modules, vendor)</li>
			<li>Результаты выполнения тестов (например, информация о покрытии кода тестами)</li>
		</ul>
	</p>

	<p>
		Всё это в обычной ситуации не должно попадать в репозиторий. Как правило, эти файлы не несут никакой пользы
		с точки зрения исходного кода. Они создаются либо автоматически (кеши, логи), либо по запросу
		(например, скачиваются зависимости или собирается проект). Главная проблема с этими файлами в их постоянном
		изменении при, как правило, очень больших размерах. Если добавлять их в репозиторий,
		то практически в каждом коммите, кроме изменений исходного кода, будет и пачка изменений в этих файлах.
		Читать историю таких коммитов крайне сложно.
	</p>

	<p>
		Git позволяет гибко настраивать игнорирование определенных файлов и директорий.
		<br>Делается это с помощью файла <b>.gitignore</b>, который нужно создать в корне проекта:
	</p>

	<code>
		В этом файле можно оставлять комментарии
		<br>
		<br>Имя файла .gitignore
		<br>Файл нужно создать самостоятельно
		<br>Каждая строчка — это шаблон, по которому происходит игнорирование
		<br>
		<br>Игнорируется файл в любой директории проекта
		<br>access.log
		<br>
		<br>Игнорируется директория в любой директории проекта
		<br>node_modules
		<br>
		<br>Игнорируется каталог в корне рабочей директории
		<br>/coverage
		<br>
		<br>Игнорируются все файлы с расширением sqlite3 в директории db,
		<br>но не игнорируются такие же файлы внутри любого вложенного каталога в db
		<br>например, /db/something/lala.sqlite3
		<br>
		<br>/db/*.sqlite3
		<br>
		<br>игнорировать все .txt файлы в каталоге doc/
		<br>на всех уровнях вложенности
		<br>doc/**/*.txt
	</code>

	<p>
		Git поддерживает игнорирование файлов, но сам его не настраивает.
		<br>Для игнорирования файлов и директорий, программист должен создать файл <b>.gitignore</b> в корне проекта,
		например как тут и добавить его в репозиторий.
	</p>

	<code>
		touch .gitignore
		<br>
		<br># добавляем в файл правила игнорирования по примеру выше
		<br>git add .gitignore
		<br>git commit ...
	</code>

	<p>
		Как только Git "увидит" файл .gitignore, то игнорирование заработает автоматически.
		Все новые файлы, попадающие под игнорирование, не отобразятся в выводе команды <b>git status</b>.
	</p>

	<p>
		Иногда бывает такое, что программист случайно уже добавил в репозиторий файл, который нужно проигнорировать.
		В этой ситуации недостаточно обновить правила игнорирования.
		Дополнительно придется удалить файл или директорию из git с помощью <b>git rm</b> и закоммитить.
	</p>



	<hr> <!-- **************** Stash (archive)  **************** -->


	<h4>Stash (archive)</h4>

	<p>
		Представьте себе ситуацию. Вы работаете над какой-то важной задачей и исправили довольно много файлов.
		<br>В этот момент появляется срочная задача — сделать какое-то изменение в исходном коде, не связанное с тем,
		над чем вы сейчас работаете. Ваши изменения ещё не готовы и они не должны попасть в репозиторий.
		<br>Что делать?
		<br>
		<br>В самом простом случае, если ваши изменения не пересекаются с изменениями по срочной задаче,
		вы можете внести исправления, добавить их в индекс, закоммитить и запушить.
		<br>Но обычно это неудобно и не всегда возможно. А если изменения нужно делать в тех файлах,
		с которыми вы работаете прямо сейчас?
		<br>
		<br>Подобная ситуация у опытных разработчиков встречается регулярно и, к счастью, она легко решается.
		<br>В git существует набор команд, позволяющий «прятать» изменения в рабочей директории и
		восстанавливать их при необходимости.
		<br>Попробуем:
	</p>

	<h4>git stash</h4>

	<code>
		touch FILE.md
		<br>git add FILE.md
		<br>git status
		<br>
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br>Changes to be committed:
		<br>(use "git restore --staged ..." to unstage)
		<br>new file:   FILE.md
		<br>
		<br>#Прячем файлы. После этой команды пропадут все изменённые файлы независимо от того,
	    добавлены они в индекс или нет.
		<br>
		<br>git stash
		<br>Saved working directory and index state WIP on main: e7bb5e5 update README.md
		<br>
		<br>git status
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br>nothing to commit, working tree clean
	</code>

	<p>
		<b>git stash</b> не удаляет файлы, они попадают в специальное место внутри директории .git «на сохранение».
		Эта команда не трогает новые файлы, так как они ещё не являются частью репозитория.
	</p>

	<p><a href="https://cdn2.hexlet.io/store/derivatives/original/cbff4655ed243ea0e7f3f49e752b859f.jpg" target="_blank">img</a></p>

	<h4>git stash pop</h4>

	<p>
		После выполнения всех нужных изменений на чистой рабочей директории
		можно вернуть спрятанные изменения с помощью команды <b>git stash pop</b>:
	</p>

	<code>
		# Восстанавливаем
		<br>
		<br>git stash pop
		<br>
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br>Changes to be committed:
		<br>(use "git restore --staged ..." to unstage)
		<br>new file:   FILE.md
		<br>Dropped refs/stash@{0} (b896d4a0126ef4409ede63857e5d996953fe75c5)
		<br>
		<br># Проверяем
		<br>
		<br>git status
		<br>
		<br>On branch main
		<br>Your branch is up to date with 'origin/main'.
		<br>Changes to be committed:
		<br>(use "git restore --staged ..." to unstage)
		<br>new file:   FILE.md
		<br>
		<br>Файлы вернулись в том виде, в котором они попали в стеш (stash).
	</code>

	<p>
		Stash в Git работает по принципу стека.
		<br>Он позволяет сохранить внутрь любое количество изменений и восстановить их в обратном порядке:
	</p>

	<code>
		git stash
		<br>
		<br># изменяем файлы
		<br>git stash
		<br>
		<br># Вернутся последние изменения
		<br>git stash pop
		<br>
		<br># Вернутся предпоследние изменения
		<br>git stash pop
	</code>

	<p>
		Дополнительные материалы:
		<br>
		<a href="https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA" target="_blank">Припрятывание (Stash) и очистка</a>
	</p>




	<hr> <!-- **************** Open Source  **************** -->



	<p>
		Open Source Software (OSS; разг. опенсорс) — это программное обеспечение (ПО),
		<br>код которого открыт (его можно посмотреть), и на него почти всегда можно влиять.
	</p>

	<p>
		Мы как программисты каждый день пользуемся программным обеспечением с открытым исходным кодом.
		К такому ПО относится как прикладное, например, VSCode или Git, так и огромное число библиотек в нашем коде,
		а также практически все современные языки программирования. Та скорость, с которой могут разрабатываться
		современные проекты, во многом возможна как раз благодаря программам и библиотекам с открытым исходным кодом.
	</p>

	<ul>
		<li>Linux (> 12 миллионов строк кода)</li>
		<li>Chromium (> 16 000 000)</li>
		<li>Git</li>
		<li>jQuery</li>
	</ul>

	<p>
		Откуда вообще берутся опенсорс-проекты и почему они так популярны? Почти всегда такой код появляется как
		побочный продукт разработки других проектов. Например, в процессе разработки Linux появилась необходимость в
		удобной программе для управления версиями. Так появился Git. Но почему его код был открыт?
		<br>Ответ достаточно простой. Удачные проекты привлекают множество разработчиков, которые помогают им развиваться.
		<br>Они пишут отчёты об ошибках, присылают исправления и даже становятся полноправными разработчиками.
		<br>И всё это бесплатно. Разработчики удовлетворяют своё эго, радуются тому, что создают нечто новое и вообще
		помогают этой вселенной. Как побочный эффект, такие разработчики гораздо легче находят работу и, в целом,
		имеют более прокачанные навыки кодирования, чем те, кто не работает с открытыми проектами.
		<br>
		<br>Если вы вернетесь в прошлое и посмотрите, сколько опенсорс-проектов создавалось тогда и сколько там было
		задействовано людей, то вы увидите огромный разрыв с современным положением дел. Сложный процесс
		включения в разработку, сложный процесс принятия изменений — вот неполный перечень проблем, ожидавших тех,
		кто желал стать участником этого движения.
		<br>Люди выступали с докладами на конференциях,
		где час (Карл!!!) описывали правила принятия людей и кода от них в проект.
		<br>
		<br>Сейчас начать делать опенсорс стало делом пары минут, а чтобы начать где-то участвовать, не нужно
		прилагать практически никаких усилий. А случилось это благодаря двум составляющим: Git и GitHub.
		<br>
		<br>Один из важнейших механизмов GitHub — запрос на включение изменений (pull request; разг. пулреквест).
		<br>Именно он позволяет легко и непринуждённо вливаться в разработку любых проектов. Допустим,
		работая с определённой библиотекой, мы заметили ошибку в коде или документации.
		<br>
		<br>Пройдёмся по шагам, которые необходимо выполнить для исправления этой ошибки.
		<br>Наша конечная цель в том, чтобы разработчики библиотеки приняли наш код.
	</p>

	<h4>Клонирование</h4>

	<p>
		Первым шагом необходимо создать копию (клон) репозитория в своём аккаунте.
		<br>Делается это буквально одной кнопкой «Fork» на странице репозитория.
	</p>

	<p><a href="https://cdn2.hexlet.io/store/derivatives/original/1b6c4b40e469c6190fc297194e39cae6.png" target="_blank">img</a></p>

	<p>
		После этого действия в вашем аккаунте окажется репозиторий с таким же именем. GitHub знает,
		что это копия оригинального репозитория, и помечает его особым образом. Дальше всё как обычно.
		Мы клонируем репозиторий на компьютер и производим необходимые изменения.
		<br>Хорошей практикой считается делать изменения в отдельной ветке (обычно созданной от ветки main).
	</p>

	<h4>Запрос на включение изменений кода</h4>

	<p>
		После того, как изменения залиты на GitHub, в его интерфейсе произойдут изменения.
		<br>На странице склонированного репозитория появится кнопка «pull request».
		<br>
		<br><a href="https://cdn2.hexlet.io/store/derivatives/original/bf87a42b812b68743db2950394e92c83.png" target="_blank">img</a>
		<br>
		<br>Если её нажать, то откроется страница, на которой можно указать название пулреквеста и его описание.
		<br>После отправки пулреквеста в исходном (оригинальном) репозитории
		на странице «Pull requests» отобразится ваш запрос.
		<br>Теперь остаётся ждать, когда разработчики библиотеки либо его примут, либо отклонят,
		либо зададут уточняющие вопросы (тогда с пулреквестом, возможно, потребуется ещё поработать).
	</p>

	<h4 id="end">Исправления прямо на Гитхабе</h4>

	<p>
		В более простых ситуациях, когда достаточно исправить текст или опечатку,
		Github позволяет сделать пулреквест прямо из своего интерфейса.
		<br>Для этого достаточно открыть любой файл проекта и нажать на иконку редактирования.
		<br>После завершения редактирования Github сам предложит создать пулреквест с этим изменением.
		<br>
		<br>Дополнительные материалы
	</p>

	<p><a href="https://www.youtube.com/watch?v=pUT3mx1ZRUM" target="_blank">Отправка пулреквестов в опенсорс</a></p>
	<p><a href="https://guides.hexlet.io/how-to-be-a-helpful-for-the-hexlet-community/" target="_blank">Опенсорс Хекслета</a></p>

	<hr>

	<p><a href="#wrapper">Вверх страницы</a></p>

	<hr> <!-- Lecture materials, saved for reference only. All rights to the materials belong to their owners. -->

	</div>


<!-- **************** * **************** -->


<!-- немного стилей -->
<style type="text/css">

	body {
		background-color: #dddfe6;
		font-size: 16px;}

	p {color: #1c1e24;}
	a {color: #3366CC;}

	#wrapper {
		width: 720px;
  		margin: 0 auto;
  		text-align: left;}

	hr {
		align: center;
		width: 100%;
		size: 2;
		color: #990033;}

	code {
		color: #003399;
		font-size: 14px;}

</style>

</html>
